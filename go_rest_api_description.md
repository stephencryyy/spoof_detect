# Описание Go REST API Сервера и Фронтенд Приложения в проекте RealTone

## Введение

Go REST API сервер является центральным компонентом бэкенда в проекте RealTone. Он выполняет роль фасада, принимая HTTP-запросы от клиентских приложений (например, веб-фронтенда), обрабатывая их, взаимодействуя с другими сервисами (такими как Python gRPC сервис для анализа аудио и S3-совместимое хранилище MinIO), и управляя данными в PostgreSQL базе данных.

Фронтенд-приложение, разработанное на Next.js и React, предоставляет пользовательский интерфейс для взаимодействия с бэкендом, загрузки аудиофайлов, просмотра результатов анализа и управления задачами.

## Зачем используется REST API (для Бэкенда)?

Для клиентского API (взаимодействие с фронтендом или внешними системами) был выбран REST по следующим причинам:

*   **Широкая распространенность**: RESTful API являются стандартом де-факто для веб-сервисов, поддерживаются всеми языками программирования и фреймворками.
*   **Простота использования**: HTTP методы (GET, POST, PUT, DELETE) и статусные коды интуитивно понятны.
*   **Бесстатусные запросы**: Каждый запрос содержит всю необходимую информацию, что упрощает масштабирование.
*   **Поддержка JSON**: JSON является легковесным и человекочитаемым форматом данных, удобным для веб-приложений.

## Архитектура и логика работы (Бэкенд - Go REST API)

Go REST API выступает в роли оркестратора всей системы:

*   **Точка входа**: Принимает HTTP-запросы от клиентов.
*   **Управление файлами**: Обрабатывает загрузку аудиофайлов от пользователей и сохраняет их в S3-хранилище (MinIO).
*   **Оркестрация анализа**: Инициирует процесс анализа аудио, отправляя запросы к Python gRPC сервису.
*   **Управление задачами**: Отслеживает статус задач анализа, сохраняя информацию в базе данных.
*   **Хранение результатов**: Сохраняет результаты анализа, полученные от Python-сервиса, в базе данных.
*   **Аутентификация и авторизация**: Управляет доступом пользователей к API, используя JWT-токены.

**Общая схема взаимодействия (Бэкенд):**

1.  Клиент (веб-интерфейс) отправляет HTTP-запрос на Go REST API сервер (например, для загрузки аудиофайла и его анализа).
2.  Go сервер обрабатывает запрос: аутентифицирует пользователя, валидирует данные.
3.  Аудиофайл загружается в S3-хранилище (MinIO).
4.  Go сервер создает задачу на анализ в базе данных PostgreSQL.
5.  Go сервер отправляет gRPC-запрос Python-сервису, передавая ему информацию о файле в S3.
6.  Python-сервис скачивает файл из S3, проводит анализ и возвращает результат Go-серверу по gRPC.
7.  Go сервер сохраняет результат анализа в PostgreSQL и обновляет статус задачи.
8.  Клиент может запросить статус задачи и получить результаты анализа через другие эндпоинты Go REST API.

## Структура проекта и назначение файлов/директорий (Бэкенд - `go_web/`)

Проект имеет следующую структуру в директории `go_web/`:

*   **`cmd/server/main.go`**: Точка входа приложения.
    *   **Назначение**: Инициализирует все основные компоненты сервера: конфигурацию, логгер, подключение к базе данных, S3-сервис, gRPC-клиент для связи с Python-сервисом, HTTP-роутер (Gin Gonic), репозитории, сервисы (включая сервис аутентификации) и регистрирует HTTP хэндлеры.
    *   **Логика**: Загружает конфигурацию из переменных окружения и `.env` файла. Настраивает и запускает HTTP-сервер.

*   **`internal/`**: Содержит всю основную бизнес-логику приложения, не предназначенную для использования другими проектами.
    *   **`internal/auth/auth.go`**: Логика аутентификации и авторизации.
        *   **Назначение**: Генерация и проверка JWT-токенов, управление сессиями пользователей (если применимо), проверка прав доступа.
        *   **Логика**: Содержит функции для создания токенов при логине, middleware для проверки токенов в каждом защищенном запросе.

    *   **`internal/config/config.go`**: Управление конфигурацией приложения.
        *   **Назначение**: Загрузка и предоставление доступа к параметрам конфигурации (например, адреса баз данных, порты, секретные ключи) из переменных окружения или конфигурационных файлов (например, `.env`).
        *   **Логика**: Использует библиотеки (например, `godotenv`, `cleanenv`) для чтения и парсинга конфигурации.

    *   **`internal/database/database.go`**: Взаимодействие с базой данных PostgreSQL.
        *   **Назначение**: Установка соединения с БД, выполнение миграций (если используются), предоставление объекта соединения для репозиториев.
        *   **Логика**: Инициализирует пул соединений к PostgreSQL, используя драйвер (например, `pgx`).

    *   **`internal/grpc_clients/python_audio_analyzer_client.go`**: Клиент для взаимодействия с Python gRPC сервисом анализа аудио.
        *   **Назначение**: Отправка запросов на анализ аудио Python-сервису и получение результатов.
        *   **Логика**: Устанавливает gRPC-соединение с Python-сервером, вызывает его методы, обрабатывает ответы и ошибки.

    *   **`internal/handlers/`**: HTTP хэндлеры (контроллеры).
        *   **Назначение**: Обработка входящих HTTP-запросов, вызов соответствующих сервисов для выполнения бизнес-логики, формирование HTTP-ответов.
        *   **Логика**: Каждый файл или группа файлов обычно отвечает за определенный ресурс или группу эндпоинтов (например, `auth_handler.go`, `audio_handler.go`). Хэндлеры принимают `gin.Context`, извлекают данные из запроса, вызывают сервисы и возвращают JSON-ответы или ошибки.

    *   **`internal/middleware/`**: HTTP middleware (промежуточное ПО).
        *   **Назначение**: Выполнение сквозных задач для HTTP-запросов, таких как логирование, CORS, аутентификация, восстановление после паник.
        *   **Логика**: Функции, которые выполняются до или после основных хэндлеров запросов. Например, `cors.go` для настройки CORS, `auth_middleware.go` для проверки JWT-токенов.

    *   **`internal/models/`**: Модели данных (структуры Go).
        *   **Назначение**: Определение структур, представляющих сущности данных в приложении (например, `User`, `AudioFile`, `AnalysisResult`). Эти структуры используются для работы с базой данных и для формирования JSON-ответов/запросов.
        *   **Логика**: Простые Go-структуры с тегами для сериализации/десериализации JSON и для работы с ORM или драйвером БД.

    *   **`internal/repository/`**: Репозитории для работы с базой данных.
        *   **Назначение**: Абстрагирование логики доступа к данным. Предоставляют CRUD (Create, Read, Update, Delete) операции для моделей данных.
        *   **Логика**: Содержат SQL-запросы или вызовы ORM для взаимодействия с таблицами базы данных. Например, `user_repository.go` будет содержать функции для сохранения, поиска, обновления пользователей.

    *   **`internal/s3service/s3service.go`**: Сервис для работы с S3-совместимым хранилищем (MinIO).
        *   **Назначение**: Загрузка, скачивание, удаление файлов из S3-хранилища, проверка/создание бакетов.
        *   **Логика**: Использует AWS SDK for Go (или аналогичную библиотеку) для взаимодействия с S3 API.

    *   **`internal/service/`**: Сервисный слой, содержащий бизнес-логику.
        *   **Назначение**: Координация работы между хэндлерами, репозиториями и другими сервисами. Здесь реализуется основная бизнес-логика приложения, не связанная напрямую с HTTP или базой данных.
        *   **Логика**: Например, `audio_service.go` может содержать логику по созданию задачи на анализ, вызову gRPC-клиента, обновлению статуса задачи.

*   **`pkg/`**: Пакеты, которые могут быть использованы другими проектами (хотя в данном контексте `internal/` более распространено для внутренней логики).
    *   **`pkg/logger/`**: Утилиты для логирования.
        *   **Назначение**: Инициализация и предоставление экземпляра логгера (например, Zap или Logrus) для использования во всем приложении.
        *   **Логика**: Настройка формата логов, уровней логирования, вывода (консоль, файл).

    *   **`pkg/utils/`**: Общие вспомогательные функции.
        *   **Назначение**: Набор небольших утилит, которые могут быть полезны в разных частях приложения (например, генерация случайных строк, работа с датами, хэширование паролей и т.д.).
        *   **Логика**: Коллекция независимых функций.

*   **`go.mod` и `go.sum`**: Файлы управления зависимостями Go.
    *   **Назначение**: `go.mod` определяет модуль проекта и его зависимости. `go.sum` содержит контрольные суммы зависимостей для обеспечения воспроизводимости сборок.

*   **`.env` (или `.env.example`)**: Файл для хранения переменных окружения для локальной разработки.
    *   **Назначение**: Содержит конфигурационные параметры, такие как строки подключения к БД, ключи API, порты и т.д. `.env` обычно добавляется в `.gitignore`.

*   **`Dockerfile`**: (Если используется Docker) Файл для сборки Docker-образа приложения.
    *   **Назначение**: Описывает шаги для создания контейнеризированной версии приложения.

*   **`README.md`**: Файл с описанием проекта, инструкциями по сборке, запуску и т.д.

Эта структура помогает организовать код, разделить зоны ответственности и облегчает поддержку и развитие проекта.

## Frontend Приложения RealTone (Анализатор Аудио)

### 1. Обзор Архитектуры (Фронтенд)

Фронтенд приложения RealTone разработан с использованием **Next.js (App Router)** и **React**, обеспечивая современный и производительный пользовательский интерфейс. Стилизация реализована с помощью **Tailwind CSS** и библиотеки компонентов **shadcn/ui**.

Ключевой функционал сосредоточен вокруг загрузки аудиофайлов, их анализа (через взаимодействие с бэкендом) и интерактивного воспроизведения с визуализацией результатов. Состояние компонентов управляется с помощью встроенных React-хуков (`useState`, `useEffect`, `useRef`, `useCallback`).

**Основные технологические аспекты (Фронтенд):**

*   **Фреймворк:** Next.js 13+ (App Router)
*   **Язык:** TypeScript
*   **UI компоненты:** shadcn/ui (на базе Radix UI и Tailwind CSS)
*   **Стилизация:** Tailwind CSS
*   **Визуализация аудио:** WaveSurfer.js для отображения волновой формы и регионов.
*   **Воспроизведение аудио:** HTML5 Audio API (для сегментов) и WaveSurfer.js (для основного трека).
*   **Взаимодействие с API:** `fetch` API (обернутый в кастомные функции, например, `uploadAudio` в `lib/api.ts`).
*   **Управление состоянием:** Локальное состояние компонентов React.
*   **Аутентификация (текущая реализация):** Моковая, с использованием `localStorage` для хранения JWT токена.
*   **Локальное хранение (история):** `localStorage` для сохранения истории анализов.

### 2. Структура Проекта (Фронтенд - Ключевые Директории)

Структура проекта соответствует стандартной для Next.js приложений с App Router (предполагается, что фронтенд находится в директории `frontend/` внутри `go_web/` или в корне проекта):

*   `frontend/` (или `realtone/` если это отдельный репозиторий/проект)
    *   `app/`: Основная директория приложения.
        *   `api/`: API-маршруты Next.js (например, `api/check/route.ts` для загрузки и первоначальной обработки аудио, если используется проксирование через Next.js).
        *   `(pages)/`: Группы маршрутов для страниц (например, `auth`, `history`, главная страница `page.tsx`).
        *   `layout.tsx`: Корневой макет приложения.
        *   `globals.css`: Глобальные стили.
    *   `components/`: Переиспользуемые React-компоненты.
        *   `ui/`: UI-компоненты из shadcn/ui (Button, Card, Input и т.д.).
        *   `audio-player.tsx`: Компонент для воспроизведения отдельных аудиосегментов.
        *   `audio-waveform.tsx`: Компонент для отображения и воспроизведения основной аудиоволны с регионами анализа.
        *   `upload-form.tsx`: Центральный компонент, управляющий загрузкой, анализом и отображением результатов.
        *   `header.tsx`, `auth/login-form.tsx`, и т.д.
    *   `lib/`: Вспомогательные модули.
        *   `api.ts`: Функции для взаимодействия с Go REST API (например, `uploadAudio`).
        *   `types.ts`: Определения TypeScript интерфейсов для данных (например, `UploadAudioResponse`, `AnalysisResultItem`).
        *   `utils.ts`: Общие утилиты.
    *   `public/`: Статические ассеты.
    *   `tailwind.config.ts`, `next.config.mjs`, `package.json`: Файлы конфигурации.

### 3. Ключевые Компоненты и Взаимодействия (Фронтенд)

Центральным элементом пользовательского интерфейса для анализа аудио является компонент `upload-form.tsx`. Он координирует работу нескольких других компонентов и управляет большей частью состояния, связанного с процессом анализа и воспроизведения.

#### 3.1. `upload-form.tsx`

**Обязанности:**

*   **Выбор файла:** Позволяет пользователю выбрать аудиофайл для анализа. Управляет состоянием `file`.
*   **Локальное аудио:** Создает `Blob` URL (`localFileBlobUrl`) для немедленного использования локально выбранного файла (например, для плееров сегментов). Получает длительность аудио (`audioDuration`) из локального файла.
*   **Запрос на анализ:**
    *   При нажатии кнопки "Анализировать" отправляет файл на бэкенд с помощью функции `uploadAudio` из `lib/api.ts`.
    *   Передает JWT токен из `localStorage` для аутентификации запроса к Go REST API.
    *   Обрабатывает ответ от бэкенда (`UploadAudioResponse`), который включает URL файла в S3, ID файла и результаты анализа от Python-сервиса (`analysis_results`).
*   **Управление состоянием анализа:**
    *   `isAnalyzing`: Флаг состояния анализа.
    *   `error`: Хранение сообщений об ошибках.
    *   `audioUrl`: URL для `AudioWaveform` (сначала `blob:`, затем URL из S3).
    *   `analysisResultsApi`: Результаты анализа, полученные от API.
    *   `suspiciousSections`: Обработанный список сегментов для отображения, включая `chunk_id`, временные метки, вероятность.
*   **Управление воспроизведением (координатор):**
    *   `activePlayerKey: string | null`: Хранит ключ активного в данный момент плеера (`"waveform"` или `chunk_id` сегмента).
    *   `activePlayerProgress: { key: string, current: number, total: number } | null`: Хранит прогресс активного плеера.
    *   `handlePlayRequest(playerKeyToActivate)`: Обрабатывает запросы на воспроизведение от дочерних плееров, обеспечивая эксклюзивное воспроизведение. Обновляет `activePlayerKey` и сбрасывает `activePlayerProgress` при необходимости.
    *   `handlePlayerEnded(endedPlayerKey)`: Сбрасывает `activePlayerKey` и `activePlayerProgress`, когда плеер заканчивает воспроизведение.
    *   `handleProgressUpdate(playerKey, currentTime, duration)`: Обновляет `activePlayerProgress` на основе данных от активного плеера (вызывается через `requestAnimationFrame` из дочерних плееров).
*   **Отображение результатов:**
    *   Передает данные в `AudioWaveform` для отрисовки волны и регионов.
    *   Рендерит список "подозрительных секций" (`suspiciousSections`).
    *   Для каждого сегмента в списке отображается его номер, временные метки, вероятность и кнопка `AudioPlayer`.
    *   **Динамическая подсветка прогресса сегмента:** Фон активного сегмента закрашивается градиентом (`linear-gradient`), цвет которого зависит от вероятности подделки, а заполнение градиента отражает текущий прогресс воспроизведения этого сегмента.
*   **Сохранение в историю:** Сохраняет результаты анализа в `localStorage`.

#### 3.2. `audio-waveform.tsx` (с WaveSurfer.js)

**Обязанности:**

*   **Отображение волны:** Инициализирует WaveSurfer.js для отображения волновой формы аудиофайла по `audioUrl`.
*   **Отображение регионов анализа:** Получает `analysisData` и отрисовывает регионы на вейвформе с помощью `RegionsPlugin`. Цвет региона зависит от `score` (вероятности).
*   **Встроенный плеер:**
    *   Предоставляет кнопки Play/Pause для основного трека.
    *   Взаимодействует с `UploadForm` через пропсы:
        *   `playerKey`: Уникальный идентификатор (например, `"waveform"`).
        *   `activePlayerKey`: Определяет, должен ли этот плеер быть активным.
        *   `onPlayRequest`: Вызывается при нажатии Play/Pause для координации с `UploadForm`.
        *   `onEnded`: Уведомляет `UploadForm` об окончании воспроизведения.
        *   `onProgressUpdate`: Уведомляет `UploadForm` о текущем прогрессе воспроизведения (используя `requestAnimationFrame` для плавной анимации).
    *   Отображает текущее время и общую длительность трека.
*   **Навигация:** Позволяет пользователю кликать на регионы для перемотки аудио.

#### 3.3. `audio-player.tsx` (для сегментов)

**Обязанности:**

*   **Воспроизведение сегментов:** Использует HTML5 `<audio>` элемент для воспроизведения определенного участка аудиофайла, заданного `startTime` и `endTime`. Использует `localFileBlobUrl` для надежного воспроизведения.
*   **Компактный интерфейс:** Обычно отображается как небольшая кнопка Play/Pause.
*   **Взаимодействие с `UploadForm`:** Аналогично `AudioWaveform`, использует пропсы `playerKey` (это `chunk_id` сегмента), `activePlayerKey`, `onPlayRequest`, `onEnded`, `onProgressUpdate` для интеграции в общую систему управления воспроизведением и обновления прогресса.
*   **Плавное обновление прогресса:** Использует `requestAnimationFrame` для вызова `onProgressUpdate`.

#### 3.4. Типы данных (`lib/types.ts`)

Определяет ключевые структуры данных, используемые во фронтенде:

*   `AnalysisResultItem`: Структура для одного сегмента анализа (результат от Python gRPC).
    *   `chunk_id: string`
    *   `score: number` (вероятность)
    *   `start_time_seconds: number`
    *   `end_time_seconds: number`
*   `UploadAudioResponse`: Структура ответа от бэкенд API Go (например, `/api/v1/audio/upload`).
    *   `file_id: string`
    *   `s3_key: string`
    *   `message: string`
    *   `file_url?: string` (URL файла в S3)
    *   `analysis_error?: string` (ошибка от Python-сервиса)
    *   `analysis_results?: AnalysisResultItem[]`
    *   `error?: string` (общая ошибка от Go API)
*   `SuspiciousSection` (в `UploadForm.tsx`): Локальный тип для отображения сегментов в UI, производный от `AnalysisResultItem`.
    *   `sectionNumber: number`
    *   `startTime: number`
    *   `endTime: number`
    *   `probability: number` (0-100)
    *   `chunk_id: string`

#### 3.5. API взаимодействия (`lib/api.ts`)

Содержит функцию `uploadAudio(file: File, token: string): Promise<UploadAudioResponse>`, которая:
*   Формирует `FormData` с файлом.
*   Отправляет POST-запрос на эндпоинт Go REST API (например, `/api/v1/audio/upload`).
*   Включает `Authorization` заголовок с JWT токеном.
*   Возвращает промис с `UploadAudioResponse`.

### 4. Логика Работы Ключевого Функционала (Фронтенд)

#### 4.1. Загрузка и Анализ Аудиофайла

1.  **Выбор файла:** Пользователь выбирает аудиофайл через `<input type="file">` в `UploadForm`.
2.  **Локальная подготовка:**
    *   Создается `blob:` URL (`localFileBlobUrl`) для выбранного файла. Этот URL немедленно используется компонентами `AudioPlayer` для сегментов.
    *   `audioUrl` для `AudioWaveform` также инициализируется этим `blob:` URL.
    *   Определяется длительность аудиофайла (`audioDuration`) локально.
3.  **Анализ (при нажатии кнопки):**
    *   `UploadForm` вызывает `uploadAudio(file, token)` из `lib/api.ts`.
    *   Файл отправляется на Go REST API.
    *   Go API загружает файл в MinIO, затем вызывает Python gRPC сервис для анализа.
    *   Go API возвращает `UploadAudioResponse`, включающий `file_url` (из MinIO) и `analysis_results` (от Python).
4.  **Обработка ответа в `UploadForm`:**
    *   `audioUrl` обновляется на `file_url` из ответа (для `AudioWaveform`).
    *   `analysisResultsApi` заполняется данными `analysis_results`.
    *   Длительность последнего сегмента в `analysisResultsApi` корректируется, чтобы не превышать `audioDuration` (если аудио короче, чем сумма длин чанков).
    *   Формируется массив `suspiciousSections` для отображения в UI, каждый элемент содержит `chunk_id`.
    *   Отображается `AudioWaveform` с результатами и список сегментов.
5.  **Сохранение в историю:** Результаты анализа (имя файла, вероятность, детальные результаты) сохраняются в `localStorage`.

#### 4.2. Воспроизведение Аудио и Визуализация Прогресса

1.  **Единый источник управления:** `UploadForm` управляет тем, какой плеер (основная вейвформа или один из сегментов) активен в данный момент через состояние `activePlayerKey`.
2.  **Запрос на воспроизведение:**
    *   При клике на Play в `AudioWaveform` или `AudioPlayer`, компонент вызывает `onPlayRequest(playerKey)` (где `playerKey` это `"waveform"` или `chunk_id`).
    *   `UploadForm.handlePlayRequest` обновляет `activePlayerKey`. Если пользователь кликает на Play уже активного плеера, `activePlayerKey` становится `null` (пауза).
3.  **Активация плеера:**
    *   `AudioWaveform` и `AudioPlayer` получают `activePlayerKey` как проп.
    *   Если `activePlayerKey` совпадает с их собственным `playerKey`, они начинают воспроизведение. В противном случае – ставят себя на паузу.
4.  **Обновление прогресса:**
    *   Активный плеер (`AudioWaveform` или `AudioPlayer`) использует `requestAnimationFrame` для частого вызова `onProgressUpdate(playerKey, currentTime, duration)`.
    *   `UploadForm.handleProgressUpdate` обновляет состояние `activePlayerProgress`.
5.  **Визуализация прогресса сегмента в `UploadForm`:**
    *   Для каждого элемента списка сегментов, если он активен (`activePlayerKey === segment.chunk_id`) и есть данные в `activePlayerProgress`:
        *   Рассчитывается процент проигранной части сегмента.
        *   Фон `div` этого сегмента стилизуется с помощью `linear-gradient`, где цвет зависит от `probability`, а заполнение градиента показывает прогресс.
6.  **Окончание воспроизведения:**
    *   Когда воспроизведение в `AudioWaveform` или `AudioPlayer` заканчивается (или достигает `endTime` для сегмента), он вызывает `onEnded(playerKey)`.
    *   `UploadForm.handlePlayerEnded` сбрасывает `activePlayerKey` и `activePlayerProgress`.

### 5. Технический Стек (Фронтенд)

*   **Frontend**: React, Next.js (App Router)
*   **Стилизация**: Tailwind CSS, shadcn/ui
*   **Визуализация аудио**: WaveSurfer.js
*   **Хранение данных (клиент)**: `localStorage` (для истории и мок-токена)
*   **API**: Взаимодействие с Go REST API через `fetch`.
*   **Аутентификация**: Моковая (localStorage).

Этот документ должен дать более полное представление о бэкенд и фронтенд частях приложения RealTone.