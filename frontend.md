# Frontend Приложения RealTone (Анализатор Аудио)

## 1. Обзор Архитектуры

Фронтенд приложения RealTone разработан с использованием **Next.js (App Router)** и **React**, обеспечивая современный и производительный пользовательский интерфейс. Стилизация реализована с помощью **Tailwind CSS** и библиотеки компонентов **shadcn/ui**.

Ключевой функционал сосредоточен вокруг загрузки аудиофайлов, их анализа (через взаимодействие с бэкендом) и интерактивного воспроизведения с визуализацией результатов. Состояние компонентов управляется с помощью встроенных React-хуков (`useState`, `useEffect`, `useRef`, `useCallback`).

**Основные технологические аспекты:**

*   **Фреймворк:** Next.js 13+ (App Router)
*   **Язык:** TypeScript
*   **UI компоненты:** shadcn/ui (на базе Radix UI и Tailwind CSS)
*   **Стилизация:** Tailwind CSS
*   **Визуализация аудио:** WaveSurfer.js для отображения волновой формы и регионов.
*   **Воспроизведение аудио:** HTML5 Audio API (для сегментов) и WaveSurfer.js (для основного трека).
*   **Взаимодействие с API:** `fetch` API (обернутый в кастомные функции, например, `uploadAudio` в `lib/api.ts`).
*   **Управление состоянием:** Локальное состояние компонентов React.
*   **Аутентификация (текущая реализация):** Моковая, с использованием `localStorage` для хранения JWT токена.
*   **Локальное хранение (история):** `localStorage` для сохранения истории анализов.

## 2. Структура Проекта (Ключевые Директории)

Структура проекта соответствует стандартной для Next.js приложений с App Router:

*   `realtone/`
    *   `app/`: Основная директория приложения.
        *   `api/`: API-маршруты Next.js (например, `api/check/route.ts` для загрузки и первоначальной обработки аудио).
        *   `(pages)/`: Группы маршрутов для страниц (например, `auth`, `history`, главная страница `page.tsx`).
        *   `layout.tsx`: Корневой макет приложения.
        *   `globals.css`: Глобальные стили.
    *   `components/`: Переиспользуемые React-компоненты.
        *   `ui/`: UI-компоненты из shadcn/ui (Button, Card, Input и т.д.).
        *   `audio-player.tsx`: Компонент для воспроизведения отдельных аудиосегментов.
        *   `audio-waveform.tsx`: Компонент для отображения и воспроизведения основной аудиоволны с регионами анализа.
        *   `upload-form.tsx`: Центральный компонент, управляющий загрузкой, анализом и отображением результатов.
        *   `header.tsx`, `auth/login-form.tsx`, и т.д.
    *   `lib/`: Вспомогательные модули.
        *   `api.ts`: Функции для взаимодействия с бэкенд API (например, `uploadAudio`).
        *   `types.ts`: Определения TypeScript интерфейсов для данных (например, `UploadAudioResponse`, `AnalysisResultItem`).
        *   `utils.ts`: Общие утилиты.
    *   `public/`: Статические ассеты.
    *   `tailwind.config.ts`, `next.config.mjs`, `package.json`: Файлы конфигурации.

## 3. Ключевые Компоненты и Взаимодействия

Центральным элементом пользовательского интерфейса для анализа аудио является компонент `upload-form.tsx`. Он координирует работу нескольких других компонентов и управляет большей частью состояния, связанного с процессом анализа и воспроизведения.

### 3.1. `upload-form.tsx`

**Обязанности:**

*   **Выбор файла:** Позволяет пользователю выбрать аудиофайл для анализа. Управляет состоянием `file`.
*   **Локальное аудио:** Создает `Blob` URL (`localFileBlobUrl`) для немедленного использования локально выбранного файла (например, для плееров сегментов). Получает длительность аудио (`audioDuration`) из локального файла.
*   **Запрос на анализ:**
    *   При нажатии кнопки "Анализировать" отправляет файл на бэкенд с помощью функции `uploadAudio` из `lib/api.ts`.
    *   Передает JWT токен из `localStorage` для аутентификации запроса.
    *   Обрабатывает ответ от бэкенда (`UploadAudioResponse`), который включает URL файла в S3, ID файла и результаты анализа от Python-сервиса (`analysis_results`).
*   **Управление состоянием анализа:**
    *   `isAnalyzing`: Флаг состояния анализа.
    *   `error`: Хранение сообщений об ошибках.
    *   `audioUrl`: URL для `AudioWaveform` (сначала `blob:`, затем URL из S3).
    *   `analysisResultsApi`: Результаты анализа, полученные от API.
    *   `suspiciousSections`: Обработанный список сегментов для отображения, включая `chunk_id`, временные метки, вероятность.
*   **Управление воспроизведением (координатор):**
    *   `activePlayerKey: string | null`: Хранит ключ активного в данный момент плеера (`"waveform"` или `chunk_id` сегмента).
    *   `activePlayerProgress: { key: string, current: number, total: number } | null`: Хранит прогресс активного плеера.
    *   `handlePlayRequest(playerKeyToActivate)`: Обрабатывает запросы на воспроизведение от дочерних плееров, обеспечивая эксклюзивное воспроизведение. Обновляет `activePlayerKey` и сбрасывает `activePlayerProgress` при необходимости.
    *   `handlePlayerEnded(endedPlayerKey)`: Сбрасывает `activePlayerKey` и `activePlayerProgress`, когда плеер заканчивает воспроизведение.
    *   `handleProgressUpdate(playerKey, currentTime, duration)`: Обновляет `activePlayerProgress` на основе данных от активного плеера (вызывается через `requestAnimationFrame` из дочерних плееров).
*   **Отображение результатов:**
    *   Передает данные в `AudioWaveform` для отрисовки волны и регионов.
    *   Рендерит список "подозрительных секций" (`suspiciousSections`).
    *   Для каждого сегмента в списке отображается его номер, временные метки, вероятность и кнопка `AudioPlayer`.
    *   **Динамическая подсветка прогресса сегмента:** Фон активного сегмента закрашивается градиентом (`linear-gradient`), цвет которого зависит от вероятности подделки, а заполнение градиента отражает текущий прогресс воспроизведения этого сегмента.
*   **Сохранение в историю:** Сохраняет результаты анализа в `localStorage`.

### 3.2. `audio-waveform.tsx` (с WaveSurfer.js)

**Обязанности:**

*   **Отображение волны:** Инициализирует WaveSurfer.js для отображения волновой формы аудиофайла по `audioUrl`.
*   **Отображение регионов анализа:** Получает `analysisData` и отрисовывает регионы на вейвформе с помощью `RegionsPlugin`. Цвет региона зависит от `score` (вероятности).
*   **Встроенный плеер:**
    *   Предоставляет кнопки Play/Pause для основного трека.
    *   Взаимодействует с `UploadForm` через пропсы:
        *   `playerKey`: Уникальный идентификатор (например, `"waveform"`).
        *   `activePlayerKey`: Определяет, должен ли этот плеер быть активным.
        *   `onPlayRequest`: Вызывается при нажатии Play/Pause для координации с `UploadForm`.
        *   `onEnded`: Уведомляет `UploadForm` об окончании воспроизведения.
        *   `onProgressUpdate`: Уведомляет `UploadForm` о текущем прогрессе воспроизведения (используя `requestAnimationFrame` для плавной анимации).
    *   Отображает текущее время и общую длительность трека.
*   **Навигация:** Позволяет пользователю кликать на регионы для перемотки аудио.

### 3.3. `audio-player.tsx` (для сегментов)

**Обязанности:**

*   **Воспроизведение сегментов:** Использует HTML5 `<audio>` элемент для воспроизведения определенного участка аудиофайла, заданного `startTime` и `endTime`. Использует `localFileBlobUrl` для надежного воспроизведения.
*   **Компактный интерфейс:** Обычно отображается как небольшая кнопка Play/Pause.
*   **Взаимодействие с `UploadForm`:** Аналогично `AudioWaveform`, использует пропсы `playerKey` (это `chunk_id` сегмента), `activePlayerKey`, `onPlayRequest`, `onEnded`, `onProgressUpdate` для интеграции в общую систему управления воспроизведением и обновления прогресса.
*   **Плавное обновление прогресса:** Использует `requestAnimationFrame` для вызова `onProgressUpdate`.

### 3.4. Типы данных (`lib/types.ts`)

Определяет ключевые структуры данных, используемые во фронтенде:

*   `AnalysisResultItem`: Структура для одного сегмента анализа (результат от Python gRPC).
    *   `chunk_id: string`
    *   `score: number` (вероятность)
    *   `start_time_seconds: number`
    *   `end_time_seconds: number`
*   `UploadAudioResponse`: Структура ответа от бэкенд API (`/api/v1/audio/upload` или мок `/api/check`).
    *   `file_id: string`
    *   `s3_key: string`
    *   `message: string`
    *   `file_url?: string` (URL файла в S3)
    *   `analysis_error?: string` (ошибка от Python-сервиса)
    *   `analysis_results?: AnalysisResultItem[]`
    *   `error?: string` (общая ошибка)
*   `SuspiciousSection` (в `UploadForm.tsx`): Локальный тип для отображения сегментов в UI, производный от `AnalysisResultItem`.
    *   `sectionNumber: number`
    *   `startTime: number`
    *   `endTime: number`
    *   `probability: number` (0-100)
    *   `chunk_id: string`

### 3.5. API взаимодействия (`lib/api.ts`)

Содержит функцию `uploadAudio(file: File, token: string): Promise<UploadAudioResponse>`, которая:
*   Формирует `FormData` с файлом.
*   Отправляет POST-запрос на бэкенд эндпоинт (например, `/api/v1/audio/upload`).
*   Включает `Authorization` заголовок с JWT токеном.
*   Возвращает промис с `UploadAudioResponse`.

## 4. Логика Работы Ключевого Функционала (с учетом последних изменений)

### 4.1. Загрузка и Анализ Аудиофайла

1.  **Выбор файла:** Пользователь выбирает аудиофайл через `<input type="file">` в `UploadForm`.
2.  **Локальная подготовка:**
    *   Создается `blob:` URL (`localFileBlobUrl`) для выбранного файла. Этот URL немедленно используется компонентами `AudioPlayer` для сегментов.
    *   `audioUrl` для `AudioWaveform` также инициализируется этим `blob:` URL.
    *   Определяется длительность аудиофайла (`audioDuration`) локально.
3.  **Анализ (при нажатии кнопки):**
    *   `UploadForm` вызывает `uploadAudio(file, token)`.
    *   Файл отправляется на бэкенд (Go API).
    *   Go API загружает файл в MinIO, затем вызывает Python gRPC сервис для анализа.
    *   Go API возвращает `UploadAudioResponse`, включающий `file_url` (из MinIO) и `analysis_results` (от Python).
4.  **Обработка ответа в `UploadForm`:**
    *   `audioUrl` обновляется на `file_url` из ответа (для `AudioWaveform`).
    *   `analysisResultsApi` заполняется данными `analysis_results`.
    *   Длительность последнего сегмента в `analysisResultsApi` корректируется, чтобы не превышать `audioDuration` (если аудио короче, чем сумма длин чанков).
    *   Формируется массив `suspiciousSections` для отображения в UI, каждый элемент содержит `chunk_id`.
    *   Отображается `AudioWaveform` с результатами и список сегментов.
5.  **Сохранение в историю:** Результаты анализа (имя файла, вероятность, детальные результаты) сохраняются в `localStorage`.

### 4.2. Воспроизведение Аудио и Визуализация Прогресса

1.  **Единый источник управления:** `UploadForm` управляет тем, какой плеер (основная вейвформа или один из сегментов) активен в данный момент через состояние `activePlayerKey`.
2.  **Запрос на воспроизведение:**
    *   При клике на Play в `AudioWaveform` или `AudioPlayer`, компонент вызывает `onPlayRequest(playerKey)` (где `playerKey` это `"waveform"` или `chunk_id`).
    *   `UploadForm.handlePlayRequest` обновляет `activePlayerKey`. Если пользователь кликает на Play уже активного плеера, `activePlayerKey` становится `null` (пауза).
3.  **Активация плеера:**
    *   `AudioWaveform` и `AudioPlayer` получают `activePlayerKey` как проп.
    *   Если `activePlayerKey` совпадает с их собственным `playerKey`, они начинают воспроизведение. В противном случае – ставят себя на паузу.
4.  **Обновление прогресса:**
    *   Активный плеер (`AudioWaveform` или `AudioPlayer`) использует `requestAnimationFrame` для частого вызова `onProgressUpdate(playerKey, currentTime, duration)`.
    *   `UploadForm.handleProgressUpdate` обновляет состояние `activePlayerProgress`.
5.  **Визуализация прогресса сегмента в `UploadForm`:**
    *   Для каждого элемента списка сегментов, если он активен (`activePlayerKey === segment.chunk_id`) и есть данные в `activePlayerProgress`:
        *   Рассчитывается процент проигранной части сегмента.
        *   Фон `div` этого сегмента стилизуется с помощью `linear-gradient`, где цвет зависит от `probability`, а заполнение градиента показывает прогресс.
6.  **Окончание воспроизведения:**
    *   Когда воспроизведение в `AudioWaveform` или `AudioPlayer` заканчивается (или достигает `endTime` для сегмента), он вызывает `onEnded(playerKey)`.
    *   `UploadForm.handlePlayerEnded` сбрасывает `activePlayerKey` и `activePlayerProgress`.

## 5. Технический Стек (без изменений по сравнению с предыдущим файлом)

*   **Frontend**: React, Next.js (App Router)
*   **Стилизация**: Tailwind CSS, shadcn/ui
*   **Визуализация аудио**: WaveSurfer.js
*   **Хранение данных (клиент)**: `localStorage` (для истории и мок-токена)
*   **API**: Next.js API Routes (для проксирования или моков), взаимодействие с Go REST API.
*   **Аутентификация**: Моковая (localStorage).

Этот документ должен дать полное представление о текущем состоянии вашего фронтенд-приложения.
