# Python gRPC Audio Analysis Service for Spoof Detection

Этот сервис является Python-компонентом в распределенной системе детекции аудио дипфейков. 
Он реализован как gRPC сервер, который принимает запросы на анализ аудиофайлов, хранящихся в MinIO, 
обрабатывает их с помощью ML-модели (WavLM) и возвращает предсказания по чанкам.

## Архитектура и Взаимодействие

Python gRPC сервис разработан для асинхронной работы с вышестоящим Go-сервисом (REST API).

1.  **Go REST API** (не часть этого репозитория):
    *   Принимает аудиофайл от пользователя.
    *   Загружает файл в **MinIO**.
    *   Сохраняет метаданные о задаче в **PostgreSQL** (включая `task_id`, путь к файлу в MinIO, статус).
    *   Асинхронно (в горутине) отправляет gRPC запрос этому Python-сервису.
    *   Немедленно отвечает пользователю (например, HTTP 202 Accepted + `task_id`).

2.  **Python gRPC Сервис** (данный компонент):
    *   Принимает gRPC запрос `AnalyzeAudioRequest` от Go-сервиса. Запрос содержит:
        *   `minio_bucket_name`: Имя бакета в MinIO.
        *   `minio_object_key`: Ключ (путь) к аудиофайлу в указанном бакете.
    *   Скачивает указанный аудиофайл из **MinIO**.
    *   **Предобработка аудио**: Конвертирует аудио в WAV PCM, 16 бит, 16 кГц, моно.
    *   **Нарезка на чанки**: Делит аудио на непересекающиеся чанки по 4 секунды.
    *   **Кэширование чанков в Redis**: Каждый аудио-чанк сохраняется в Redis для временного хранения перед обработкой моделью. Это также может быть полезно для повторной обработки или отладки.
    *   **Параллельный инференс**: Для каждого чанка (извлеченного из Redis) параллельно выполняется предсказание с использованием ML-модели (WavLM).
    *   Модель возвращает `score` (от 0.0 до 1.0) для каждого чанка, где 0.0 - "очень вероятно настоящий", 1.0 - "очень вероятно фейк".
    *   Формирует gRPC ответ `AnalyzeAudioResponse`, содержащий:
        *   `predictions`: Карта (map) `string -> float`, где ключ - идентификатор чанка (например, `"chunk_0"`), а значение - предсказанный `score`.
        *   `error_message`: Сообщение об ошибке, если что-то пошло не так во время обработки.
    *   Отправляет ответ обратно Go-сервису.

3.  **Go REST API** (продолжение):
    *   Горутина, получившая ответ от Python-сервиса, обновляет статус задачи и сохраняет предсказания в **PostgreSQL**.
    *   (Опционально) Уведомляет пользователя о завершении задачи (например, через WebSockets).

**Стек технологий Python-сервиса:**
*   **gRPC**: для межсервисного взаимодействия с Go.
*   **Python**: язык реализации.
*   **PyTorch**: для работы с ML-моделью.
*   **Transformers (Hugging Face)**: для загрузки и использования предобученной модели WavLM.
*   **Torchaudio**: для операций с аудио (загрузка, ресемплинг, конвертация в моно).
*   **MinIO Client (`minio`)**: для взаимодействия с объектным хранилищем MinIO.
*   **Redis Client (`redis`)**: для кэширования аудио-чанков.
*   **NumPy**: для работы с числовыми данными.

## Структура проекта (Python-часть)

```
.
├── proto/
│   └── audio_analyzer.proto  # Определение gRPC сервиса и сообщений
├── server/
│   ├── audio_analyzer_pb2.py      # Сгенерированный Python-код из .proto (сообщения)
│   ├── audio_analyzer_pb2_grpc.py # Сгенерированный Python-код из .proto (клиент и сервер)
│   ├── grpc_server.py             # Основной файл gRPC сервера, логика обработки
│   ├── inference.py               # Логика загрузки модели, предобработки и инференса
│   ├── chk.pth                    # Пример файла чекпоинта модели (ЗАМЕНИТЕ НА ВАШ)
│   └── test_client.py             # Тестовый gRPC клиент для проверки сервера
└── README.md                      # Этот файл
```

## Настройка и Запуск

### 1. Предварительные требования

*   **Python** (рекомендуется версия 3.9+).
*   **Pip** (менеджер пакетов Python).
*   **MinIO сервер**: Запущен и доступен. У вас должны быть эндпоинт, ключ доступа, секретный ключ и имя бакета.
*   **Redis сервер**: Запущен и доступен (по умолчанию `localhost:6379`).
*   **Файл чекпоинта модели**: Файл с весами вашей обученной модели (например, `chk.pth`) должен находиться в директории `server/` или путь к нему должен быть корректно указан в `server/inference.py` (константа `CHECKPOINT_FILE`).

### 2. Установка зависимостей

В корневой директории проекта (или в директории `server/`, если вы предпочитаете держать зависимости там) создайте и активируйте виртуальное окружение:

```bash
python -m venv .venv
# Для Windows (PowerShell):
.venv\Scripts\Activate.ps1
# Для Linux/macOS:
source .venv/bin/activate
```

Установите необходимые Python-библиотеки:

```bash
# Находясь в активированном окружении
# Основные зависимости для gRPC, модели и аудио
pip install grpcio grpcio-tools torch torchaudio transformers numpy
# Клиенты для MinIO и Redis
pip install minio redis
```

### 3. Генерация gRPC кода (если вы меняли `.proto` файл)

Если вы внесли изменения в `proto/audio_analyzer.proto`, перегенерируйте Python-код:

```bash
# Находясь в корневой директории проекта
python -m grpc_tools.protoc -I./proto --python_out=./server --grpc_python_out=./server ./proto/audio_analyzer.proto
```

### 4. Настройка переменных окружения

Перед запуском `server/grpc_server.py`, необходимо установить следующие переменные окружения для подключения к MinIO и Redis:

*   **Для MinIO:**
    *   `MINIO_ENDPOINT`: Эндпоинт вашего MinIO сервера (например, `localhost:9000`).
    *   `MINIO_ACCESS_KEY`: Ваш ключ доступа к MinIO.
    *   `MINIO_SECRET_KEY`: Ваш секретный ключ к MinIO.
    *   `MINIO_SECURE`: Установите `True`, если ваше MinIO соединение использует HTTPS, иначе `False` (по умолчанию `False`).

*   **Для Redis (опционально, если отличается от значений по умолчанию):**
    *   `REDIS_HOST`: Хост Redis (по умолчанию `localhost`).
    *   `REDIS_PORT`: Порт Redis (по умолчанию `6379`).

**Пример установки переменных окружения (Linux/macOS):**
```bash
export MINIO_ENDPOINT="localhost:9000"
export MINIO_ACCESS_KEY="your_access_key"
export MINIO_SECRET_KEY="your_secret_key"
export MINIO_SECURE="False"
```
**Пример установки переменных окружения (Windows PowerShell):**
```powershell
$env:MINIO_ENDPOINT = "localhost:9000"
$env:MINIO_ACCESS_KEY = "your_access_key"
$env:MINIO_SECRET_KEY = "your_secret_key"
$env:MINIO_SECURE = "False"
```

### 5. Запуск gRPC сервера

Убедитесь, что ваше виртуальное окружение активировано и все переменные окружения установлены.

```bash
# Находясь в корневой директории проекта
python server/grpc_server.py
```

Сервер должен запуститься и вывести сообщения о загрузке модели, подключении к Redis и MinIO, а также о прослушивании порта (по умолчанию `[::]:50052`).

### 6. Тестирование сервера (опционально, с помощью `test_client.py`)

Тестовый клиент `server/test_client.py` позволяет отправить запрос на сервер для проверки его работоспособности.

1.  **Подготовьте тестовый файл в MinIO**:
    *   Убедитесь, что ваш MinIO сервер запущен.
    *   Создайте бакет (если его еще нет).
    *   Загрузите в этот бакет тестовый аудиофайл.

2.  **Настройте `test_client.py`**:
    *   Откройте файл `server/test_client.py`.
    *   Измените значения констант `TEST_MINIO_BUCKET_NAME` и `TEST_MINIO_OBJECT_KEY` так, чтобы они соответствовали вашему тестовому файлу в MinIO.

3.  **Запустите `test_client.py`** (в отдельном терминале, с активированным виртуальным окружением):
    ```bash
    # Находясь в корневой директории проекта
    python server/test_client.py
    ```

    Клиент отправит запрос, а в его консоли и в консоли сервера вы увидите логи обработки и результат.

## Основные компоненты кода

*   **`server/grpc_server.py`**: 
    *   `AudioAnalysisServicer`: Класс, реализующий gRPC сервис.
        *   `__init__()`: Инициализация модели, Redis клиента, MinIO клиента.
        *   `AnalyzeAudio()`: Основной метод, обрабатывающий gRPC запросы. Включает скачивание из MinIO, предобработку аудио, нарезку на чанки, сохранение/получение чанков из Redis, параллельный запуск инференса для каждого чанка.
        *   `_process_chunk_from_redis()`: Вспомогательный метод для обработки одного чанка.
        *   `_predict_score_for_chunk_tensor()`: Выполняет инференс для тензора чанка.
    *   `serve()`: Функция для запуска gRPC сервера.

*   **`server/inference.py`**: (Предполагается, что этот файл существует и содержит)
    *   `CustomWavLMForClassification`: Класс вашей ML-модели.
    *   `load_model_from_checkpoint()`: Функция для загрузки весов модели из файла чекпоинта.
    *   Константы `MODEL_CHECKPOINT`, `SAMPLE_RATE`, `NUM_SAMPLES`, `CHECKPOINT_FILE`.
    *   Функции предобработки аудио (если они там).

## Дальнейшие возможные доработки

*   **Улучшенное логирование**: Использование модуля `logging` вместо `print()`.
*   **Более гибкая конфигурация**: Использование `.env` файлов или конфигурационных файлов (YAML, JSON).
*   **Метрики для Prometheus**: Интеграция с `prometheus_client` для сбора метрик производительности.
*   **Unit-тесты и интеграционные тесты**.
*   **Обработка `task_id`**: Если Go-сервис будет передавать `task_id`, его можно использовать для более детального логирования и, возможно, для формирования ключей в Redis.

## Детальный Анализ Проекта

Этот раздел предоставляет углубленный анализ архитектуры, компонентов и рабочего процесса проекта.

### 1. Обзор Проекта

Проект представляет собой систему, предназначенную для обнаружения аудио-спуфинга (идентификации дипфейков или поддельных аудиозаписей). Он включает в себя веб-интерфейс для загрузки аудиофайлов пользователями и бэкенд-систему, которая анализирует эти файлы с помощью модели машинного обучения для определения, являются ли они подлинными или поддельными.

### 2. Архитектура

Система использует микросервисную архитектуру с отдельными компонентами для обработки веб-запросов, выполнения анализа аудио и управления хранилищем данных.

*   **Фронтенд**: (Предположительно) Клиентское приложение (вероятно, в `go_web/frontend/`), позволяющее пользователям взаимодействовать с системой (например, регистрироваться, входить в систему, загружать аудио).
*   **Веб-сервис на Go**: Бэкенд-сервис, созданный с использованием фреймворка Gin (Go), расположенный в `go_web/`. Он предоставляет REST API для:
    *   Аутентификации пользователей (регистрация, вход с использованием JWT).
    *   Загрузки аудиофайлов.
    *   Взаимодействия с Python-сервисом анализа аудио через gRPC.
*   **Python-сервис анализа аудио**: gRPC-сервис, расположенный в `server/`. Он отвечает за основной ML-анализ аудио. Сервис:
    *   Получает запросы на анализ от Go-сервиса.
    *   Извлекает аудиофайлы из MinIO.
    *   Предварительно обрабатывает аудио и выполняет инференс с использованием модели PyTorch (`chk3.pth`).
    *   Использует Redis для временного хранения фрагментов аудио (чанков) во время обработки.
*   **База данных PostgreSQL**: Реляционная база данных (имя сервиса `postgres_db` в Docker Compose), используемая Go-сервисом для хранения информации о пользователях и, возможно, других данных приложения. Инициализация схемы выполняется скриптом `go_web/scripts/init.sql`.
*   **Объектное хранилище MinIO**: S3-совместимый сервис объектного хранения (имя сервиса `minio` в Docker Compose), используемый для хранения загруженных аудиофайлов.
*   **Кэш Redis**: Хранилище данных в памяти (имя сервиса `redis_cache` в Docker Compose), используемое Python-сервисом анализа аудио для временного кэширования аудио-чанков.

**Диаграмма взаимодействия (концептуальная):**

```
[Фронтенд] <--HTTP--> [Веб-сервис на Go (Gin)] <--gRPC--> [Python-сервис анализа аудио (PyTorch)]
    |                            |                                     |
    |                            +--------> [PostgreSQL]               |
    |                            |                                     |
    +----------------------------+--------> [MinIO] <-----------------+
                                                                     |
                                                                     +--------> [Redis]
```

### 3. Компоненты Системы

*   **`go_web/`**: Содержит веб-приложение на Go.
    *   `cmd/server/main.go`: Точка входа для сервера Gin на Go.
    *   `internal/`: Содержит бизнес-логику (аутентификация, обработчики, взаимодействие с БД, сервис S3).
    *   `Dockerfile`: Для контейнеризации приложения на Go.
    *   `docker-compose.yml`: Оркестрирует приложение на Go, PostgreSQL, MinIO и Redis. **Примечание: Этот файл в настоящее время не включает Python gRPC сервис.**
    *   `.env` (ожидается): Содержит переменные окружения для приложения на Go и других сервисов в Docker Compose.
*   **`server/`**: Содержит Python gRPC сервис анализа аудио.
    *   `grpc_server.py`: Реализует gRPC-сервер и RPC-метод `AnalyzeAudio`.
    *   `inference.py`: Содержит определение ML-модели (`CustomWavLMForClassification`), логику загрузки модели и утилиты предварительной обработки аудио.
    *   `chk3.pth`: Предварительно обученный чекпоинт модели PyTorch для обнаружения спуфинга.
    *   `audio_analyzer_pb2.py`, `audio_analyzer_pb2_grpc.py`: Python gRPC-стабы, сгенерированные из `.proto` файла.
*   **`proto/`**:
    *   `audio_analyzer.proto`: Определяет gRPC-сервис `AudioAnalysis` и его сообщения запроса/ответа для связи между сервисами на Go и Python.
*   **`model/`**:
    *   `main.py`: Содержит скрипты и утилиты, связанные с обучением и экспериментами с ML-моделью. В основном используется для оффлайн-разработки модели.
*   **`requirements.txt`**: Перечисляет Python-зависимости для сервиса анализа аудио (например, `torch`, `torchaudio`, `transformers`, `grpcio`, `minio`, `redis`).
*   `MINIO_ENDPOINT`, `MINIO_ACCESS_KEY`, `MINIO_SECRET_KEY`, `MINIO_SECURE`: Детали подключения к MinIO.
*   gRPC-сервер слушает порт `50052` (жестко задан).

**Сервисы Docker Compose (из `.env` в `go_web/`):**
*   `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB`
*   `MINIO_ROOT_USER`, `MINIO_ROOT_PASSWORD` (для настройки MinIO)
*   `MINIO_API_PORT`, `MINIO_CONSOLE_PORT`

### 4. Пример Рабочего Процесса: Загрузка и Анализ Аудио

1.  Пользователь регистрируется/входит в систему через Фронтенд и загружает аудиофайл.
2.  Фронтенд отправляет файл на эндпоинт `/api/v1/audio/upload` **Веб-сервиса на Go**.
3.  Go-сервис аутентифицирует пользователя (используя JWT) и загружает полученный аудиофайл в **MinIO**.
4.  Затем Go-сервис выполняет gRPC-вызов метода `AnalyzeAudio` **Python-сервиса анализа аудио**, передавая имя бакета MinIO и ключ объекта для загруженного файла.
5.  Python-сервис получает запрос, подключается к **MinIO** и загружает указанный аудиофайл.
6.  Аудиоданные предварительно обрабатываются:
    *   Загружаются и декодируются с использованием `torchaudio`.
    *   Передискретизируются до 16 кГц (целевая `SAMPLE_RATE`).
    *   Конвертируются в один канал (моно).
    *   Разделяются на фрагменты (чанки) фиксированной длины (например, 4 секунды, на основе `NUM_SAMPLES`).
7.  Эти аудио-чанки временно сохраняются в **Redis** с использованием уникального идентификатора запроса.
8.  Python-сервис извлекает каждый чанк из Redis и передает его в предварительно обученную модель `CustomWavLMForClassification` (`chk3.pth`) для инференса.
9.  Модель выводит оценку (score) для каждого чанка, указывающую на вероятность того, что он является поддельным.
10. Эти оценки собираются в карту (ID чанка -> оценка) и возвращаются Веб-сервису на Go в `AnalyzeAudioResponse`. Сообщение об ошибке возвращается, если какой-либо шаг завершается неудачно.
11. Веб-сервис на Go получает gRPC-ответ и затем может передать результаты анализа обратно на Фронтенд или сохранить их по мере необходимости.

### 5. Ключевые Технологии

*   **Бэкенд (API и Оркестрация)**: Go (Golang), фреймворк Gin
*   **Бэкенд (ML Анализ)**: Python, PyTorch, Hugging Face Transformers (WavLM)
*   **Межсервисное Взаимодействие**: gRPC
*   **База Данных**: PostgreSQL
*   **Объектное Хранилище**: MinIO (S3-совместимое)
*   **Кэш**: Redis
*   **Контейнеризация и Оркестрация**: Docker, Docker Compose

### 6. Конфигурация (Ключевые Переменные Окружения)

Сервисы зависят от переменных окружения для конфигурации. Обычно они устанавливаются в файле `.env` в директории `go_web/` для Docker Compose и напрямую для Python-сервиса, если он запускается вне Compose.

**Веб-сервис на Go (`go_app` в Docker Compose):**
*   `GO_APP_PORT`: Порт для веб-сервера на Go (например, 8080).
*   `DB_HOST`: Хост базы данных (установлен как `postgres_db` в `docker-compose.yml`).
*   `DB_USER`, `DB_PASSWORD`, `DB_NAME`, `DB_PORT`: Детали подключения к PostgreSQL.
*   `S3_ENDPOINT`: Эндпоинт MinIO (например, `minio:9000`).
*   `S3_ACCESS_KEY_ID`, `S3_SECRET_ACCESS_KEY`: Учетные данные MinIO.
*   `S3_BUCKET_NAME`: Имя бакета MinIO по умолчанию.
*   `JWT_SECRET_KEY`, `JWT_EXPIRATION_HOURS`: Для JWT-аутентификации.
*   `PYTHON_GRPC_SERVICE_ADDR`: (Предполагается, **необходимо добавить**) Адрес Python gRPC-сервиса (например, `python_audio_analyzer:50052` при запуске в Docker Compose, или `localhost:50052` при локальном запуске).

**Python-сервис анализа аудио (`server/grpc_server.py`):**
*   `REDIS_HOST`, `REDIS_PORT`: Детали подключения к Redis (например, `redis_cache`, `6379` при нахождении в той же сети Docker).
*   `MINIO_ENDPOINT`, `MINIO_ACCESS_KEY`, `MINIO_SECRET_KEY`, `MINIO_SECURE`: Детали подключения к MinIO.
*   gRPC-сервер слушает порт `50052` (жестко задан).

**Сервисы Docker Compose (из `.env` в `go_web/`):**
*   `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB`
*   `MINIO_ROOT_USER`, `MINIO_ROOT_PASSWORD` (для настройки MinIO)
*   `MINIO_API_PORT`, `MINIO_CONSOLE_PORT`

### 7. Настройка и Запуск Системы

**A. Использование Docker Compose (для Go-сервиса, БД, MinIO, Redis):**

1.  Убедитесь, что Docker и Docker Compose установлены.
2.  Перейдите в директорию `go_web/`.
3.  Создайте файл `.env` в `go_web/` с необходимыми переменными окружения (см. раздел Конфигурация). Пример:
    ```env
    # go_web/.env
    GO_APP_PORT=8080

    DB_HOST=postgres_db
    DB_USER=youruser
    DB_PASSWORD=yourpassword
    DB_NAME=authdb
    DB_PORT=5432

    S3_ENDPOINT=minio:9000
    S3_ACCESS_KEY_ID=minioadmin
    S3_SECRET_ACCESS_KEY=minioadmin
    S3_BUCKET_NAME=audiofiles
    S3_USE_SSL=false # Или true, если MinIO настроен с SSL

    JWT_SECRET_KEY=yourverysecretjwtkey
    JWT_EXPIRATION_HOURS=72

    # Для самого сервиса MinIO
    MINIO_API_PORT=9000
    MINIO_CONSOLE_PORT=9001
    # MINIO_ROOT_USER и MINIO_ROOT_PASSWORD должны соответствовать S3_ACCESS_KEY_ID и S3_SECRET_ACCESS_KEY для простоты
    # или быть установлены как отдельные переменные, если это требуется для запуска образа MinIO.
    # Текущий docker-compose.yml использует S3_ACCESS_KEY_ID и S3_SECRET_ACCESS_KEY для MINIO_ROOT_USER/PASSWORD.

    # Адрес для Python-сервиса (нужен приложению на Go)
    PYTHON_GRPC_SERVICE_ADDR=python_audio_analyzer:50052 # Предполагается, что Python-сервис называется 'python_audio_analyzer' в общей сети Docker
    ```
4.  Выполните `docker-compose up --build -d`.
    *   Это соберет и запустит приложение на Go, PostgreSQL, MinIO и Redis.
    *   Go-сервис будет доступен на хосте по указанному `GO_APP_PORT`.
    *   Консоль MinIO будет доступна по `MINIO_CONSOLE_PORT`.

**B. Запуск Python-сервиса анализа аудио:**

Python gRPC-сервис (`server/grpc_server.py`) необходимо запускать как отдельный процесс.

1.  **Установите зависимости**: Если вы еще этого не сделали, установите все Python-зависимости, перечисленные в `requirements.txt`. Рекомендуется использовать виртуальное окружение:
    ```bash
    python -m venv .venv
    # Для Windows (PowerShell):
    # .venv\Scripts\Activate.ps1
    # Для Linux/macOS:
    # source .venv/bin/activate
    pip install -r requirements.txt
    ```

2.  **Установите переменные окружения**: Перед запуском `server/grpc_server.py` убедитесь, что установлены переменные окружения для подключения к MinIO и Redis (см. раздел "Конфигурация (Ключевые Переменные Окружения)").

3.  **Запустите gRPC-сервер**:
    ```bash
    # Находясь в корневой директории проекта и с активированным виртуальным окружением
    python server/grpc_server.py
    ```
    Сервер должен запуститься и вывести сообщения о загрузке модели и подключении к зависимым сервисам.

    Убедитесь, что Веб-сервис на Go (`go_app`) может связаться с Python-сервисом. Если Go-сервис работает в Docker, а Python-сервис локально, переменная `PYTHON_GRPC_SERVICE_ADDR` в `.env` файле Go-сервиса должна быть установлена соответствующим образом (например, `host.docker.internal:50052` для Docker Desktop). Если оба работают локально, то `localhost:50052` или `127.0.0.1:50052`.

**C. Локальная разработка (без Docker для одного или нескольких сервисов):**

   При запуске сервисов локально (например, Python-сервис непосредственно на хосте), убедитесь, что:
   *   Все зависимости установлены (например, `pip install -r requirements.txt` для Python).
   *   Переменные окружения установлены в вашей оболочке.
   *   Порты не конфликтуют.
   *   Сервисы могут взаимодействовать друг с другом (например, `localhost` или конкретные IP-адреса). Если Go-приложение работает в Docker, а Python локально, `PYTHON_GRPC_SERVICE_ADDR` для Go-приложения может потребоваться установить как `host.docker.internal:50052`.

### 8. Детали ML-Модели

*   **Базовая модель**: `microsoft/wavlm-base` из Hugging Face Transformers.
*   **Кастомизация**: Пользовательская классификационная "голова" (`CustomWavLMForClassification` в `server/inference.py`) добавлена поверх WavLM, состоящая из слоя адаптивного среднего пулинга и линейного слоя.
*   **Обработка входных данных**:
    *   Аудио передискретизируется до 16 кГц.
    *   Конвертируется в моно.
    *   Обрабатывается фрагментами (чанками) фиксированного размера в 4 секунды (64 000 сэмплов при 16 кГц, определяется `NUM_SAMPLES` в `server/inference.py`).
*   **Выходные данные**: Модель выводит логит, который затем передается через сигмоидную функцию в `grpc_server.py` для получения оценки (score) от 0 до 1 для каждого чанка. Эта оценка представляет собой вероятность того, что чанк является поддельным.
*   **Чекпоинт**: Обученные веса хранятся в `server/chk3.pth`.

Этот анализ должен обеспечить хорошее понимание проекта.